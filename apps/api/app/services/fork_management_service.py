import logging
import asyncio
from datetime import datetime
from typing import Optional, List, Dict, Any
from uuid import UUID

from app.models.github_config import (
    RepositoryInfo,
    ForkConfig,
    CommitInfo,
    FileOperation,
    GitCommitAction,
    ForkAndModifyRequest,
)
from app.services.github_service import github_service
from app.services.database import DatabaseService
from app.utils.repo_utils import extract_repo_info, get_default_branch

logger = logging.getLogger(__name__)


class ForkManagementService:
    """Service for managing repository forking and knowledge base creation operations"""

    def __init__(self, db: DatabaseService):
        self.db = db
        self.github_service = github_service

    async def find_repository_without_fork(self):
        """Find a repository analysis without forked_repo_url"""
        logger.info(
            "Searching for repository analysis without forked_repo_url to create knowledge base"
        )

        analysis = await self.db.get_repository_analysis_without_fork_url()

        if not analysis:
            return (
                None,
                "No repository analysis found without forked_repo_url. All repositories have been forked already.",
            )

        # Get the repository details
        repository = await self.db.get_repository(analysis.repository_id)
        if not repository:
            return None, f"Repository not found for analysis {analysis.id}"

        logger.info(
            f"Found repository analysis {analysis.id} for repository {repository.repo_url} - ready for knowledge base creation"
        )

        return (analysis, repository), None

    def create_knowledge_base_files(self, analysis, repository, repo_info, documents):
        """Create knowledge base files for the repository"""
        knowledge_base_files = []

        # Add AI summary if available
        if analysis.ai_summary and analysis.ai_summary.strip():
            ai_summary_content = f"""# AI Summary - {repo_info['repo_name']}

## Repository Information
- **Owner**: {repo_info['owner']}
- **Repository**: {repo_info['repo_name']}
- **URL**: {repository.repo_url}
- **Analysis ID**: {analysis.id}

## AI-Generated Summary

{analysis.ai_summary}

---
*Generated by Git Search API AI analysis on {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC*
"""
            knowledge_base_files.append(
                FileOperation(
                    action=GitCommitAction.CREATE,
                    path="knowledge_base/summary.md",
                    content=ai_summary_content,
                    encoding="utf-8",
                )
            )

        # Add documents
        for i, document in enumerate(documents):
            # Create a safe filename from document title
            safe_title = "".join(
                c for c in document.title if c.isalnum() or c in (" ", "-", "_")
            ).rstrip()
            safe_title = safe_title.replace(" ", "_").lower()
            filename = f"knowledge_base/{safe_title}.md"

            document_content = f"""# {document.title} - {repo_info['repo_name']}

{document.content}

---
*Generated by Git Search API on {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC*
"""
            knowledge_base_files.append(
                FileOperation(
                    action=GitCommitAction.CREATE,
                    path=filename,
                    content=document_content,
                    encoding="utf-8",
                )
            )

        # Create index file
        index_content = f"""# Knowledge Base - {repo_info['repo_name']}

## Repository Information
- **Owner**: {repo_info['owner']}
- **Repository**: {repo_info['repo_name']}
- **URL**: {repository.repo_url}
- **Analysis ID**: {analysis.id}

## Analysis Statistics
- **Files Processed**: {analysis.files_processed or 0}
- **Total Files**: {analysis.total_files_found or 0}
- **Total Lines**: {analysis.total_lines or 0}
- **Estimated Tokens**: {analysis.estimated_tokens or 0}
- **Total Directories**: {analysis.total_directories or 0}

## Knowledge Base Contents

### Core Documents
"""

        if analysis.ai_summary and analysis.ai_summary.strip():
            index_content += "- [AI Summary](summary.md)\n"

        index_content += "\n### Generated Documents\n"

        for i, document in enumerate(documents):
            safe_title = "".join(
                c for c in document.title if c.isalnum() or c in (" ", "-", "_")
            ).rstrip()
            safe_title = safe_title.replace(" ", "_").lower()
            filename = f"{safe_title}.md"
            index_content += f"- [{document.title}]({filename})\n"

        index_content += f"""
---
*Knowledge base generated by Git Search API on {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC*
"""

        knowledge_base_files.append(
            FileOperation(
                action=GitCommitAction.CREATE,
                path="knowledge_base/README.md",
                content=index_content,
                encoding="utf-8",
            )
        )

        return knowledge_base_files

    def create_fork_request(self, repo_info, knowledge_base_files):
        """Create a ForkAndModifyRequest for the repository"""
        # Get the actual default branch from GitHub
        default_branch = get_default_branch(repo_info["owner"], repo_info["repo_name"])
        
        source_repo = RepositoryInfo(
            owner=repo_info["owner"], name=repo_info["repo_name"], default_branch=default_branch
        )

        return ForkAndModifyRequest(
            github_config=self.github_service.config,
            source_repo=source_repo,
            fork_config=ForkConfig(
                source_repo=source_repo,
                fork_name=f"{repo_info['repo_name']}",
                organization=None,
                default_branch_only=True,
            ),
            commit_info=CommitInfo(
                message=f"Create knowledge base for {repo_info['full_name']} with {len(knowledge_base_files)} files",
                author_name="Git Search API",
                author_email="api@gitsearch.com",
                branch=default_branch,
                files=knowledge_base_files,
            ),
            push_after_commit=True,
            cleanup_after=True,
        )

    async def fork_and_create_knowledge_base(
        self, analysis, repository, documents=None
    ):
        """Fork repository and create knowledge base"""
        # Extract owner and repo name from the repository URL
        repo_info = extract_repo_info(repository.repo_url)

        logger.info(
            f"Creating knowledge base for repository analysis {analysis.id} - {repo_info['full_name']}"
        )

        # Get documents for this repository analysis if not provided
        if documents is None:
            documents = await self.db.get_documents_by_repository_analysis(analysis.id)

        # Create knowledge base files
        knowledge_base_files = self.create_knowledge_base_files(
            analysis, repository, repo_info, documents
        )

        # Create the fork request
        request = self.create_fork_request(repo_info, knowledge_base_files)

        # Execute the fork-and-modify operation
        result = await self.github_service.fork_and_modify(request)

        if result.success:
            logger.info(
                f"Knowledge base creation completed successfully for {repository.repo_url} with {len(knowledge_base_files)} files"
            )

            # Update the repository analysis with the forked repo URL
            await self.db.update_repository_analysis(
                analysis.id, {"forked_repo_url": result.fork_url}
            )

            # Prepare response data
            response_data = {
                "success": True,
                "message": f"Knowledge base created successfully with {len(knowledge_base_files)} files",
                "repository_id": str(repository.id),
                "analysis_id": str(analysis.id),
                "source_repo": repository.repo_url,
                "fork_url": result.fork_url,
                "commit_sha": result.commit_sha,
                "files_modified": result.files_modified,
                "processing_time": result.processing_time,
                "workflow_steps": (
                    result.metadata.get("workflow_steps", []) if result.metadata else []
                ),
                "total_files_modified": (
                    result.metadata.get("total_files_modified", 0)
                    if result.metadata
                    else 0
                ),
                "knowledge_base_info": {
                    "total_files_created": len(knowledge_base_files),
                    "ai_summary_included": bool(
                        analysis.ai_summary and analysis.ai_summary.strip()
                    ),
                    "description_included": bool(
                        analysis.description and analysis.description.strip()
                    ),
                    "documents_included": len(documents),
                    "knowledge_base_path": "knowledge_base/",
                },
            }

            # Add target repo info if available
            if result.target_repo:
                response_data["target_repo"] = result.target_repo.full_name

            return response_data, None
        else:
            error_msg = f"Knowledge base creation failed for {repository.repo_url}: {result.error}"
            logger.error(error_msg)
            return None, error_msg

    async def create_knowledge_base_for_analysis(
        self, analysis, repository, documents=None
    ):
        """Create knowledge base for a given analysis and repository (to be called from background tasks)"""
        # Validate that GitHub service is available
        if not self.github_service:
            return (
                None,
                "GitHub service is not available. Please check GitHub token configuration.",
            )

        # Check if analysis already has a forked repo URL
        if analysis.forked_repo_url:
            logger.info(
                f"Repository analysis {analysis.id} already has a forked repo URL: {analysis.forked_repo_url}"
            )
            return None, "Repository analysis already has a forked repo URL"

        # Fork and create knowledge base
        return await self.fork_and_create_knowledge_base(
            analysis, repository, documents
        )

    async def auto_fork_repository(self):
        """Automatically find a repository analysis and create a knowledge base"""
        # Validate that GitHub service is available
        if not self.github_service:
            return (
                None,
                "GitHub service is not available. Please check GitHub token configuration.",
            )

        # Find repository without fork
        result = await self.find_repository_without_fork()
        if result[1]:  # Error occurred
            return None, result[1]

        if not result[0]:
            return (
                None,
                "No repository analysis found without forked_repo_url. All repositories have been forked already.",
            )

        analysis, repository = result[0]

        # Fork and create knowledge base
        return await self.fork_and_create_knowledge_base(analysis, repository)


# Singleton instance
fork_management_service = None


def get_fork_management_service(db: DatabaseService) -> ForkManagementService:
    """Get or create the fork management service"""
    global fork_management_service
    if fork_management_service is None:
        fork_management_service = ForkManagementService(db)
    else:
        # Update the database connection in case it changed
        fork_management_service.db = db
    return fork_management_service
